// Generated by CoffeeScript 1.10.0
var GameState, game;

GameState = function(game) {};

GameState.prototype.preload = function() {
  this.game.load.image('ground', 'assets/gfx/ground.png');
  this.game.load.image('player', 'assets/gfx/player.png');
};

GameState.prototype.create = function() {
  var fn, i, ref, x;
  this.game.stage.backgroundColor = 0x4488cc;
  this.MAX_SPEED = 500;
  this.ACCELERATION = 1500;
  this.DRAG = 1000;
  this.GRAVITY = 2600;
  this.JUMP_SPEED = -800;
  this.player = this.game.add.sprite(this.game.width / 2, this.game.height / 2, 'player');
  this.game.physics.enable(this.player, Phaser.Physics.ARCADE);
  this.player.body.collideWorldBounds = true;
  this.player.body.maxVelocity.setTo(this.MAX_SPEED, this.MAX_SPEED * 10);
  this.player.body.drag.setTo(this.DRAG, 0);
  game.physics.arcade.gravity.y = this.GRAVITY;
  this.jumping = false;
  this.ground = this.game.add.group();
  fn = (function(_this) {
    return function(x) {
      var groundBlock;
      groundBlock = _this.game.add.sprite(x, _this.game.height - 32, 'ground');
      _this.game.physics.enable(groundBlock, Phaser.Physics.ARCADE);
      groundBlock.body.immovable = true;
      groundBlock.body.allowGravity = false;
      return _this.ground.add(groundBlock);
    };
  })(this);
  for (x = i = 0, ref = this.game.width; i <= ref; x = i += 32) {
    fn(x);
  }
  this.blockMidAir = this.game.add.sprite(this.game.width / 2, 0, 'ground');
  this.game.physics.enable(this.blockMidAir, Phaser.Physics.ARCADE);
  this.blockMidAir.body.allowGravity = true;
  this.blockMidAir.body.immovable = false;
  this.blockMidAir.body.collideWorldBounds = true;
  this.game.input.keyboard.addKeyCapture([Phaser.Keyboard.LEFT, Phaser.Keyboard.RIGHT, Phaser.Keyboard.UP, Phaser.Keyboard.DOWN]);
  this.drawHeightMarkers();
};

GameState.prototype.drawHeightMarkers = function() {
  var bitmap, fn, i, ref, y;
  bitmap = this.game.add.bitmapData(this.game.width, this.game.height);
  fn = (function(_this) {
    return function(y) {
      bitmap.context.beginPath();
      bitmap.context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      bitmap.context.moveTo(0, y);
      bitmap.context.lineTo(_this.game.width, y);
      return bitmap.context.stroke();
    };
  })(this);
  for (y = i = ref = this.game.height - 32; i >= 32; y = i += -32) {
    fn(y);
  }
  this.game.add.image(0, 0, bitmap);
};

GameState.prototype.update = function() {
  var onTheGround, xs;
  xs = [this.player, this.ground, this.blockMidAir];
  this.game.physics.arcade.collide(xs, xs);
  if (this.leftInputIsActive()) {
    this.player.body.acceleration.x = -this.ACCELERATION;
  } else if (this.rightInputIsActive()) {
    this.player.body.acceleration.x = this.ACCELERATION;
  } else {
    this.player.body.acceleration.x = 0;
  }
  onTheGround = this.player.body.touching.down;
  if (onTheGround) {
    this.jumps = 2;
    this.jumping = false;
  }
  if (this.jumps > 0 && this.upInputIsActive(300)) {
    this.player.body.velocity.y = this.JUMP_SPEED;
    this.jumping = true;
  }
  if (this.jumping && this.upInputReleased()) {
    this.jumps--;
    this.jumping = false;
  }
};

GameState.prototype.leftInputIsActive = function() {
  var isActive;
  isActive = false;
  isActive = this.input.keyboard.isDown(Phaser.Keyboard.LEFT);
  isActive |= this.game.input.activePointer.isDown && this.game.input.activePointer.x < this.game.width / 4;
  return isActive;
};

GameState.prototype.rightInputIsActive = function() {
  var isActive;
  isActive = false;
  isActive = this.input.keyboard.isDown(Phaser.Keyboard.RIGHT);
  isActive |= this.game.input.activePointer.isDown && this.game.input.activePointer.x > this.game.width / 2 + this.game.width / 4;
  return isActive;
};

GameState.prototype.upInputIsActive = function(duration) {
  var isActive;
  isActive = false;
  isActive = this.input.keyboard.downDuration(Phaser.Keyboard.UP, duration);
  isActive |= this.game.input.activePointer.justPressed(duration + 1000 / 60) && this.game.input.activePointer.x > this.game.width / 4 && this.game.input.activePointer.x < this.game.width / 2 + this.game.width / 4;
  return isActive;
};

GameState.prototype.upInputReleased = function() {
  var released;
  released = false;
  released = this.input.keyboard.upDuration(Phaser.Keyboard.UP);
  released |= this.game.input.activePointer.justReleased();
  return released;
};

game = new Phaser.Game(848, 450, Phaser.AUTO, 'game');

game.state.add('game', GameState, true);

//# sourceMappingURL=main.js.map
